---
layout: post
title: "CY3014 USB3.0控制器"
subtitle: "与FPGA高速通信"
author: "Shane"
header-img: "img/favorite.jpg"
header-mask: 0.4
tags:
  - 智能硬件
  - USB3.0
typora-root-url: ..
---

[TOC]



# USB3.0

USB2.0的最大理论传输带宽为480Mb/s(即60MB/s)，USB3.0的最大传输带宽则高达5.0Gb/s(500MB/s)。

注意：5Gb/s的带宽并不是5Gb/s除以8得到的625MB/s，而是采用与SATA相同的10位传输模式(在USB2.0的基础上新增了一对纠错码)，因此器全速只有500MB/s。

USB3.0引入全双工数据传输，5根线路中两根用来发送数据，另两根用来接收数据，还有一根地线。换句话说，USB3.0可以同步全速地进行读/写操作。以前的USB版本不支持全双工数据传输。



# USB3.0控制器FX3电路

USB3.0控制器FX3与FPGA之间通过SlaveFIFO接口互联，实现大吞吐量数据传输。

fx3_d[31:0]

fx3_a[1:0] (CTL[11]/A CTL[12]/A0)

fx3_clk (PCLK)

fx3_slcs# (CTL[0]/SLCS#)

fx3_slwr# (CTL[1]/SLWR#)

fx3_sloe# (CTL[2]/SLOE#)

fx3_rd# (CTL[3]/SLRD#)

fx3_pktend# (CTL[7]/PKTEND#)

fx3_flaga (CTL[4]/FLAGA)

fx3_flagb (CTL[5]/FLAGB)

fx3_flagc (CTL[8]/GPIO)

fx3_flagd (GTL[9]/GPIO)



复位引脚接上电复位和按键--手动复位。



启动模式：

PMODE[0]

PMODE[1]

PMODE[2]

PMODE[2:0]=F1F I2C启动，如失败，则启用USB引导

PMODE[2:-]=F11 USB引导



# USB3.0控制器FX3实例

## 基于FX3内部DMA的USB传输Loopback实例

Cypress官方提供的固件代码，在 ..\Cypress\EZ-USB FX3 SDK\1.3\fireware\basic_examples\cyfxbulklpautoenum

通过FX3的一对USB Bulk端点实现Loopback的功能。所谓Loopback，通俗地说，就是FX3接收到任何数据，就将其发送出去;从PC端的调试软件看，就是PC给FX3传输什么数据，紧接着就接收到相同的返回数据。

这个Loopback功能的实现过程中，FX3内的ARM9是不参与数据本身的任何传输的，固件配置好后，USB端点之间通过DMA自动实现数据的传输。



## 基于FX3的UVC传输协议实例



## FX3固件SlaveFIFO配置修改说明

### 功能概述

通过FX3与FPGA之家你的GPIF II接口通信，实现FPGA与FX3之间的数据交互，当然这些数据最终也传输到PC上。换句话说，通过FX3这个“桥梁”，实现FPGA与PC之间USB3.0接口的数据传输。

可以通过Cpyress官方提供的GPIF II Designer工具，获取GPIF II接口的配置参数，然后将这些参数传递给FX3的固件工程中进行编译。



## 基于FPGA-FX3 Slave FIFO接口的Loopback实例

实现PC端发送数据到FX3，FX3通过知识信号flaga告知FPGA有数据待读取，FPGA端通过SlaveFIFO接口读取PC端发送过来的数据缓存到FPGA内部的FIFO中，FPGA在完成读取操作后，发器一次SlaveFIFO的写入操作，将接收到的数据通过FX3最终返回到PC端。整个数据的收发过程可以在FPGA内部通过在线逻辑分析仪SignalTap II抓取SlaveFIFO接口的所有信号进行查看。



## 基于FPGA-FX3 Slave FIFO接口的StreamOUT实例



## 基于FPGA-FX3 Slave FIFO 接口的StreamIN实例



## 基于CORDIC的信号发生器

Coordinate Rotation Digital Comuper是CORDIC算法的英文全称，大意是指旋转坐标接近答案。



| i    | θi             | cosθi          | Πcosθi       | 1/Πcosθi    |
| ---- | -------------- | -------------- | ------------ | ----------- |
| 0    | 45.0           | 0.7071067812   | 0.7071067812 | 1.414213562 |
| 1    | 26.56505118    | 0.894427191    | 0.632455532  | 1.58113883  |
| 2    | 14.03624347    | 0.9701425001   | 0.6135719911 | 1.629800601 |
| 3    | 7.125016349    | 0.9922778767   | 0.6088339125 | 1.642484066 |
| 4    | 3.576334375    | 0.9980525785   | 0.6076482563 | 1.645688916 |
| 5    | 1.789910608    | 0.9995120761   | 0.6073517701 | 1.646492279 |
| 6    | 0.8951737102   | 0.999877952    | 0.6072776441 | 1.646693254 |
| 7    | 0.4476141709   | 0.9999694838   | 0.6072591123 | 1.646743507 |
| 8    | 0.2238105004   | 0.9999923707   | 0.6072544793 | 1.64675607  |
| 9    | 0.1119056771   | 0.99999980927  | 0.6072533211 | 1.646759211 |
| 10   | 0.05595289189  | 0.99999995232  | 0.6072530315 | 1.646759996 |
| 11   | 0.02797645262  | 0.999999998808 | 0.6072529591 | 1.646760193 |
| 12   | 0.01398822714  | 0.999999999702 | 0.607252941  | 1.646760242 |
| 13   | 0.006994113675 | 0.999999999925 | 0.6072529365 | 1.646760254 |
| 14   | 0.003497056851 | 0.999999999981 | 0.607252935  | 1.646760257 |
| 15   | 0.001748528427 | 0.999999999995 | 0.6072529351 | 1.646760258 |



```c++
#include <studio.h>

double cordic(double angle_para);

int main(void)
{
    double para;
    
    para = 30.0;
    cordic(para);
    
    return 0;
}

double cordic(double angle_para)
{
    const double tangent[] = {1.0, 1/2.0, 1/8.0, 1/16.0, 1/32.0, 1/64.0, 1/128.0, 1/512.0};
    const double angle[] = {45.0, 26.6, 14.0, 7.1, 3.6, 1.8, 0.9, 0.4, 0.2, 0.1 };
    int i, signal;
    double x_cos;
    double y_sin;
    double x_temp;
    double y_temp;
    double z;
    double z_next;
    
    x_cos = 0.0;
    y_sin = 0.0;
    z = angle_para;
    z_next = 0.0;
    x_temp = 0.6073; // Πcosθi
    y_temp = 0;
    signal = 1;
    
    for(i=0; i<9; i++)
    {
        x_cos = x_temp - signal*y_temp*tangent[i];
        y_sin = y_temp + signal*x_temp*tangent[i];
        z_next = z - signal*angle[i];
        
        x_temp = x_cos;
        y_temp = y_sin;
        z = z_next;
        
        if(z_next>0)
            signal = +1;
        else
            signal = -1; 
    }
    
    return 0;
    
}
```

